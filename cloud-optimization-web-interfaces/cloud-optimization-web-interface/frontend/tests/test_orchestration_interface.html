<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orchestration Interface Tests</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        
        .test-pass {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .test-fail {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .test-pending {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        .log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <h1>üß™ Orchestration Interface Tests</h1>
    <p>Frontend tests for the Runtime Orchestration features</p>

    <div class="test-container">
        <h2>Test Configuration</h2>
        <label>
            Backend URL: 
            <input type="text" id="backend-url" value="http://localhost:8001" style="width: 300px; padding: 5px;">
        </label>
        <br><br>
        <button onclick="runAllTests()">üöÄ Run All Tests</button>
        <button onclick="clearResults()">üßπ Clear Results</button>
    </div>

    <div class="test-container">
        <h2>Test Results</h2>
        <div id="test-results"></div>
        <div id="test-log" class="log" style="display: none;"></div>
        <button onclick="toggleLog()">üìã Toggle Log</button>
    </div>

    <script>
        let testResults = [];
        let testLog = [];

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            testLog.push(logMessage);
            console.log(logMessage);
            updateLogDisplay();
        }

        function updateLogDisplay() {
            const logElement = document.getElementById('test-log');
            logElement.innerHTML = testLog.join('\n');
            logElement.scrollTop = logElement.scrollHeight;
        }

        function toggleLog() {
            const logElement = document.getElementById('test-log');
            logElement.style.display = logElement.style.display === 'none' ? 'block' : 'none';
        }

        function addTestResult(testName, status, message) {
            testResults.push({ testName, status, message });
            updateResultsDisplay();
        }

        function updateResultsDisplay() {
            const resultsElement = document.getElementById('test-results');
            resultsElement.innerHTML = testResults.map(result => {
                const statusClass = result.status === 'pass' ? 'test-pass' : 
                                   result.status === 'fail' ? 'test-fail' : 'test-pending';
                const statusIcon = result.status === 'pass' ? '‚úÖ' : 
                                  result.status === 'fail' ? '‚ùå' : '‚è≥';
                return `
                    <div class="test-result ${statusClass}">
                        ${statusIcon} <strong>${result.testName}</strong><br>
                        ${result.message}
                    </div>
                `;
            }).join('');
        }

        function clearResults() {
            testResults = [];
            testLog = [];
            updateResultsDisplay();
            updateLogDisplay();
        }

        async function runAllTests() {
            clearResults();
            log('Starting orchestration interface tests...');

            const backendUrl = document.getElementById('backend-url').value;
            
            // Test 1: Orchestration Status API
            await testOrchestrationStatus(backendUrl);
            
            // Test 2: Orchestration Config API
            await testOrchestrationConfig(backendUrl);
            
            // Test 3: Routing Statistics API
            await testRoutingStatistics(backendUrl);
            
            // Test 4: Performance Metrics API
            await testPerformanceMetrics(backendUrl);
            
            // Test 5: Diagnostics API
            await testDiagnosticsAPI(backendUrl);
            
            // Test 6: Command Interface
            await testCommandInterface(backendUrl);
            
            log('All tests completed!');
        }

        async function testOrchestrationStatus(backendUrl) {
            const testName = 'Orchestration Status API';
            log(`Testing ${testName}...`);
            
            try {
                const response = await fetch(`${backendUrl}/api/orchestration/status`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Validate response structure
                if (!data.orchestrator_type) {
                    throw new Error('Missing orchestrator_type in response');
                }
                
                if (data.orchestrator_type === 'runtime_orchestrator') {
                    if (!data.enabled_runtimes || !Array.isArray(data.enabled_runtimes)) {
                        throw new Error('Missing or invalid enabled_runtimes for runtime orchestrator');
                    }
                    
                    if (!data.routing_statistics) {
                        throw new Error('Missing routing_statistics for runtime orchestrator');
                    }
                }
                
                addTestResult(testName, 'pass', `Orchestrator type: ${data.orchestrator_type}, Health: ${data.overall_health}`);
                log(`‚úÖ ${testName} passed`);
                
            } catch (error) {
                addTestResult(testName, 'fail', `Error: ${error.message}`);
                log(`‚ùå ${testName} failed: ${error.message}`);
            }
        }

        async function testOrchestrationConfig(backendUrl) {
            const testName = 'Orchestration Config API';
            log(`Testing ${testName}...`);
            
            try {
                const response = await fetch(`${backendUrl}/api/orchestration/config`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Validate response structure
                if (data.configuration) {
                    const requiredFields = ['bedrock_agent_enabled', 'agentcore_enabled'];
                    for (const field of requiredFields) {
                        if (!(field in data.configuration)) {
                            throw new Error(`Missing ${field} in configuration`);
                        }
                    }
                }
                
                if (data.environment_variables) {
                    const envVars = ['ENABLE_BEDROCK_AGENT', 'ENABLE_BEDROCK_AGENTCORE'];
                    for (const envVar of envVars) {
                        if (!(envVar in data.environment_variables)) {
                            throw new Error(`Missing ${envVar} in environment_variables`);
                        }
                    }
                }
                
                addTestResult(testName, 'pass', `Configuration loaded with ${data.runtime_count || 0} runtimes`);
                log(`‚úÖ ${testName} passed`);
                
            } catch (error) {
                addTestResult(testName, 'fail', `Error: ${error.message}`);
                log(`‚ùå ${testName} failed: ${error.message}`);
            }
        }

        async function testRoutingStatistics(backendUrl) {
            const testName = 'Routing Statistics API';
            log(`Testing ${testName}...`);
            
            try {
                const response = await fetch(`${backendUrl}/api/orchestration/routing-stats`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Validate response structure
                if (data.routing_statistics) {
                    const requiredFields = ['total_requests', 'bedrock_agent_requests', 'agentcore_requests'];
                    for (const field of requiredFields) {
                        if (!(field in data.routing_statistics)) {
                            throw new Error(`Missing ${field} in routing_statistics`);
                        }
                    }
                }
                
                if (data.percentages) {
                    const requiredPercentages = ['bedrock_agent', 'agentcore_runtime'];
                    for (const field of requiredPercentages) {
                        if (!(field in data.percentages)) {
                            throw new Error(`Missing ${field} in percentages`);
                        }
                    }
                }
                
                const totalRequests = data.routing_statistics?.total_requests || 0;
                addTestResult(testName, 'pass', `Statistics loaded: ${totalRequests} total requests`);
                log(`‚úÖ ${testName} passed`);
                
            } catch (error) {
                addTestResult(testName, 'fail', `Error: ${error.message}`);
                log(`‚ùå ${testName} failed: ${error.message}`);
            }
        }

        async function testPerformanceMetrics(backendUrl) {
            const testName = 'Performance Metrics API';
            log(`Testing ${testName}...`);
            
            try {
                const response = await fetch(`${backendUrl}/api/orchestration/performance`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Validate response structure
                if (data.metrics) {
                    const requiredFields = ['total_requests', 'success_rate', 'failure_rate'];
                    for (const field of requiredFields) {
                        if (!(field in data.metrics)) {
                            throw new Error(`Missing ${field} in metrics`);
                        }
                    }
                    
                    // Validate percentage ranges
                    if (data.metrics.success_rate < 0 || data.metrics.success_rate > 100) {
                        throw new Error('Invalid success_rate percentage');
                    }
                }
                
                const successRate = data.metrics?.success_rate || 0;
                addTestResult(testName, 'pass', `Metrics loaded: ${successRate}% success rate`);
                log(`‚úÖ ${testName} passed`);
                
            } catch (error) {
                addTestResult(testName, 'fail', `Error: ${error.message}`);
                log(`‚ùå ${testName} failed: ${error.message}`);
            }
        }

        async function testDiagnosticsAPI(backendUrl) {
            const testName = 'Diagnostics API';
            log(`Testing ${testName}...`);
            
            try {
                const response = await fetch(`${backendUrl}/api/orchestration/diagnostics`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                // Validate response structure
                if (data.orchestrator_diagnostics) {
                    if (!data.orchestrator_diagnostics.orchestrator_type) {
                        throw new Error('Missing orchestrator_type in diagnostics');
                    }
                }
                
                if (data.environment_variables) {
                    const envVars = ['ENABLE_BEDROCK_AGENT', 'ENABLE_BEDROCK_AGENTCORE'];
                    for (const envVar of envVars) {
                        if (!(envVar in data.environment_variables)) {
                            throw new Error(`Missing ${envVar} in environment_variables`);
                        }
                    }
                }
                
                addTestResult(testName, 'pass', 'Diagnostics data loaded successfully');
                log(`‚úÖ ${testName} passed`);
                
            } catch (error) {
                addTestResult(testName, 'fail', `Error: ${error.message}`);
                log(`‚ùå ${testName} failed: ${error.message}`);
            }
        }

        async function testCommandInterface(backendUrl) {
            const testName = 'Command Interface';
            log(`Testing ${testName}...`);
            
            try {
                // Test /agentcore runtime command
                const runtimeResponse = await fetch(`${backendUrl}/api/chat/local`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: '/agentcore runtime',
                        session_id: 'test-session'
                    })
                });
                
                if (!runtimeResponse.ok) {
                    throw new Error(`Runtime command failed: HTTP ${runtimeResponse.status}`);
                }
                
                const runtimeData = await runtimeResponse.json();
                
                if (!runtimeData.response || !runtimeData.response.includes('runtime')) {
                    throw new Error('Runtime command response does not contain expected content');
                }
                
                // Test /agentcore orchestrator command
                const orchestratorResponse = await fetch(`${backendUrl}/api/chat/local`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message: '/agentcore orchestrator',
                        session_id: 'test-session'
                    })
                });
                
                if (!orchestratorResponse.ok) {
                    throw new Error(`Orchestrator command failed: HTTP ${orchestratorResponse.status}`);
                }
                
                const orchestratorData = await orchestratorResponse.json();
                
                if (!orchestratorData.response || !orchestratorData.response.includes('orchestrator')) {
                    throw new Error('Orchestrator command response does not contain expected content');
                }
                
                addTestResult(testName, 'pass', 'Runtime and orchestrator commands work correctly');
                log(`‚úÖ ${testName} passed`);
                
            } catch (error) {
                addTestResult(testName, 'fail', `Error: ${error.message}`);
                log(`‚ùå ${testName} failed: ${error.message}`);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            log('Orchestration interface tests loaded');
        });
    </script>
</body>
</html>